<?xml version="1.0" encoding="UTF-8"?>
<zabbix_export>
    <version>6.0</version>
    <date>2022-09-06T14:24:49Z</date>
    <media_types>
        <media_type>
            <name>GLPi</name>
            <type>WEBHOOK</type>
            <parameters>
                <parameter>
                    <name>alert_message</name>
                    <value>{ALERT.MESSAGE}</value>
                </parameter>
                <parameter>
                    <name>alert_subject</name>
                    <value>{ALERT.SUBJECT}</value>
                </parameter>
                <parameter>
                    <name>event_id</name>
                    <value>{EVENT.ID}</value>
                </parameter>
                <parameter>
                    <name>event_nseverity</name>
                    <value>{EVENT.NSEVERITY}</value>
                </parameter>
                <parameter>
                    <name>event_recovery_value</name>
                    <value>{EVENT.RECOVERY.VALUE}</value>
                </parameter>
                <parameter>
                    <name>event_source</name>
                    <value>{EVENT.SOURCE}</value>
                </parameter>
                <parameter>
                    <name>event_update_status</name>
                    <value>{EVENT.UPDATE.STATUS}</value>
                </parameter>
                <parameter>
                    <name>event_value</name>
                    <value>{EVENT.VALUE}</value>
                </parameter>
                <parameter>
                    <name>glpi_problem_id</name>
                    <value>{EVENT.TAGS.__zbx_glpi_problem_id}</value>
                </parameter>
                <parameter>
                    <name>glpi_token</name>
                    <value>&lt;PLACE GLPI TOKEN&gt;</value>
                </parameter>
                <parameter>
                    <name>glpi_url</name>
                    <value>&lt;PLACE GLPI URL&gt;</value>
                </parameter>
                <parameter>
                    <name>trigger_id</name>
                    <value>{TRIGGER.ID}</value>
                </parameter>
                <parameter>
                    <name>zabbix_url</name>
                    <value>{$ZABBIX.URL}</value>
                </parameter>
            </parameters>
            <attempts>1</attempts>
            <script>var GLPi = {
    params: {},

    setParams: function (params) {
        if (typeof params !== 'object') {
            return;
        }
        GLPi.params = params;
    },

    setProxy: function (HTTPProxy) {
        GLPi.HTTPProxy = HTTPProxy;
    },

    urlCheckFormat: function (url) {
        if (typeof url === 'string' &amp;&amp; !url.endsWith('/')) {
            url += '/';
        }

        if (url.indexOf('http://') === -1 &amp;&amp; url.indexOf('https://') === -1) {
            url = 'https://' + url;
        }

        return url;
    },

    getAuthToken: function (url, token) {
        var response,
            request = new HttpRequest();

        request.addHeader('Content-Type: application/json');
        request.addHeader('Authorization: user_token ' + token);

        response = request.get(url + &quot;apirest.php/initSession&quot;);

        if (response !== null) {
            try {
                response = JSON.parse(response);
            }
            catch (error) {
                Zabbix.log(4, '[ GLPi Webhook ] Failed to receive authentication token from GLPi.');
                response = null;
            }
        }

        if (Array.isArray(response)) {
            if (response[1]) {
                throw 'Error received from GLPi: ' + response[1];
            } else {
                throw 'Failed to receive authentication token from GLPi.';
            }
        }

        if (typeof response !== 'object' || !response.session_token) {
            throw 'Failed to process response received from getting GLPi authentication token. Check debug log for more information.';
        }

        return response.session_token;
    },

    getProblemUrl: function (zabbix_url, triggerid, eventid, event_source) {
        var problem_url = zabbix_url;

        if (event_source === '0') {
            problem_url += 'tr_events.php?triggerid=' + triggerid + '&amp;eventid=' + eventid;
        }

        return problem_url;
    },

    request: function (method, url, data) {
        if (typeof GLPi.params !== 'object' || typeof GLPi.params.authToken === 'undefined' || GLPi.params.authToken === '') {
            throw 'Required GLPi param authToken is not set.';
        }

        var response,
            request = new HttpRequest();

        request.addHeader('Content-Type: application/json');
        request.addHeader('Session-Token:' + GLPi.params.authToken);

        if (typeof GLPi.HTTPProxy !== 'undefined' &amp;&amp; GLPi.HTTPProxy !== '') {
            request.setProxy(GLPi.HTTPProxy);
        }

        if (typeof data !== 'undefined') {
            data = JSON.stringify(data);
        }

        Zabbix.log(4, '[ GLPi Webhook ] Sending request: ' + url + ((typeof data === 'string')
            ? ('\n' + data)
            : ''));

        switch (method) {
            case 'post':
                response = request.post(url, data);
                break;

            case 'put':
                response = request.put(url, data);
                break;

            default:
                throw 'Unsupported HTTP request method: ' + method;
        }

        Zabbix.log(4, '[ GLPi Webhook ] Received response with status code ' +
            request.getStatus() + '\n' + response);

        if (response !== null) {
            try {
                response = JSON.parse(response);
            }
            catch (error) {
                Zabbix.log(4, '[ GLPi Webhook ] Failed to parse response received from GLPi');
                response = null;
            }
        }

        if (typeof response !== 'object' || typeof response === 'undefined' || response === null) {
            throw 'Failed to process response received from GLPi. Check debug log for more information.';
        }

        if (request.getStatus() &lt; 200 || request.getStatus() &gt;= 300) {
            var message = 'Request failed with status code ' + request.getStatus();

            if (response.message) {
                message += ': ' + response.message;
            }

            throw message + ' Check debug log for more information.';
        }

        return response;
    }
};

try {
    var params = JSON.parse(value),
        glpi = {},
        url = '',
        data = {},
        comment_data,
        result = { tags: {} },
        required_params = [
            'alert_subject', 'alert_message', 'event_source', 'event_value',
            'event_update_status', 'event_recovery_value',
            'event_id', 'trigger_id', 'zabbix_url',
            'glpi_token', 'glpi_url'
        ],
        method = 'post',
        process_tags = true,
        response;

    Object.keys(params)
        .forEach(function (key) {
            if (key.startsWith('glpi_')) {
                glpi[key.substring(5)] = params[key];
            }
            else if (required_params.indexOf(key) !== -1 &amp;&amp; params[key] === '') {
                throw 'Parameter &quot;' + key + '&quot; can\'t be empty.';
            }
        });

    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {
        throw 'Incorrect &quot;event_source&quot; parameter given: ' + params.event_source + '\nMust be 0-3.';
    }

    // Check {EVENT.VALUE} for trigger-based and internal events.
    if (params.event_value !== '0' &amp;&amp; params.event_value !== '1'
        &amp;&amp; (params.event_source === '0' || params.event_source === '3')) {
        throw 'Incorrect &quot;event_value&quot; parameter given: ' + params.event_value + '\nMust be 0 or 1.';
    }

    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.
    if (params.event_update_status !== '0' &amp;&amp; params.event_update_status !== '1' &amp;&amp; params.event_source === '0') {
        throw 'Incorrect &quot;event_update_status&quot; parameter given: ' + params.event_update_status + '\nMust be 0 or 1.';
    }

    if (params.event_source !== '0' &amp;&amp; params.event_recovery_value === '0') {
        throw 'Recovery operations are supported only for trigger-based actions.';
    }

    if (typeof params.zabbix_url !== 'string' || params.zabbix_url.trim() === '' || params.zabbix_url === '{$ZABBIX.URL}') {
        throw 'Field &quot;zabbix_url&quot; cannot be empty.';
    }

    // Check for backslash in the end of url and schema.
    glpi.url = GLPi.urlCheckFormat(glpi.url);
    params.zabbix_url = GLPi.urlCheckFormat(params.zabbix_url);

    glpi.authToken = GLPi.getAuthToken(glpi.url, glpi.token);
    GLPi.setParams(glpi);

    data = {
        'input': {
            'name': params.alert_subject,
            'content': params.alert_message + '\n&lt;a href=' + GLPi.getProblemUrl(params.zabbix_url, params.trigger_id, params.event_id, params.event_source) + '&gt;Link to problem in Zabbix&lt;/a&gt;',
            'status': 1,  // Set status &quot;New&quot;
            'urgency': params.event_nseverity
        }
    };

    // In case of resolve
    if (params.event_source === '0' &amp;&amp; params.event_value === '0') {
        process_tags = false;
        dataFollowup = {
            'input': {
                'items_id': glpi.problem_id,
                'itemtype': 'Problem',
                'content': params.alert_message + '\n&lt;a href=' + GLPi.getProblemUrl(params.zabbix_url, params.trigger_id, params.event_id, params.event_source) + '&gt;Link to problem in Zabbix&lt;/a&gt;'
            }
        };
        dataProblem = {
            'id': glpi.problem_id,
            'input': {
                'name': params.alert_subject,
                'status': 5,  // Set status &quot;Solved&quot;
                'urgency': params.event_nseverity
            }
        };

        GLPi.request('put', glpi.url + 'apirest.php/Problem/' + glpi.problem_id, dataProblem);
        GLPi.request('post', glpi.url + 'apirest.php/Problem/' + glpi.problem_id + '/ITILFollowup', dataFollowup);
    }

    // In case of update
    else if (params.event_source === '0' &amp;&amp; params.event_update_status === '1') {
        process_tags = false;
        dataFollowup = {
            'input': {
                'items_id': glpi.problem_id,
                'itemtype': 'Problem',
                'content': params.alert_message + '\n&lt;a href=' + GLPi.getProblemUrl(params.zabbix_url, params.trigger_id, params.event_id, params.event_source) + '&gt;Link to problem in Zabbix&lt;/a&gt;'
            }
        };
        dataProblem = {
            'id': glpi.problem_id,
            'input': {
                'name': params.alert_subject,
                'urgency': params.event_nseverity
            }
        };

        GLPi.request('put', glpi.url + 'apirest.php/Problem/' + glpi.problem_id, dataProblem);
        GLPi.request('post', glpi.url + 'apirest.php/Problem/' + glpi.problem_id + '/ITILFollowup', dataFollowup);
    }

    // In case of problem
    else {
        response = GLPi.request('post', glpi.url + 'apirest.php/Problem/', data);
    }

    if (process_tags) {
        result.tags.__zbx_glpi_problem_id = response.id;
        result.tags.__zbx_glpi_link = glpi.url + 'front/problem.form.php?id=' + response.id;
    }

    Zabbix.log(4, '[ GLPi Webhook ] Result: ' + JSON.stringify(result));
    return JSON.stringify(result);
}
catch (error) {
    Zabbix.log(4, '[ GLPi Webhook ] ERROR: ' + error);
    throw 'Sending failed: ' + error;
}</script>
            <process_tags>YES</process_tags>
            <show_event_menu>YES</show_event_menu>
            <event_menu_url>{EVENT.TAGS.__zbx_glpi_link}</event_menu_url>
            <event_menu_name>GLPi: Problem {EVENT.TAGS.__zbx_glpi_problem_id}</event_menu_name>
            <message_templates>
                <message_template>
                    <event_source>TRIGGERS</event_source>
                    <operation_mode>PROBLEM</operation_mode>
                    <subject>[{EVENT.STATUS}] {EVENT.NAME}</subject>
                    <message>Problem started at {EVENT.TIME} on {EVENT.DATE}
Problem name: {EVENT.NAME}
Host: {HOST.NAME}
Severity: {EVENT.SEVERITY}
Operational data: {EVENT.OPDATA}
Original problem ID: {EVENT.ID}
{TRIGGER.URL}</message>
                </message_template>
                <message_template>
                    <event_source>TRIGGERS</event_source>
                    <operation_mode>RECOVERY</operation_mode>
                    <subject>[{EVENT.STATUS}] {EVENT.NAME}</subject>
                    <message>Problem has been resolved in {EVENT.DURATION} at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}
Problem name: {EVENT.NAME}
Host: {HOST.NAME}
Severity: {EVENT.SEVERITY}
Original problem ID: {EVENT.ID}
{TRIGGER.URL}</message>
                </message_template>
                <message_template>
                    <event_source>TRIGGERS</event_source>
                    <operation_mode>UPDATE</operation_mode>
                    <subject>[{EVENT.STATUS}] {EVENT.NAME}</subject>
                    <message>{USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.
{EVENT.UPDATE.MESSAGE}

Current problem status is {EVENT.STATUS}, acknowledged: {EVENT.ACK.STATUS}.</message>
                </message_template>
                <message_template>
                    <event_source>DISCOVERY</event_source>
                    <operation_mode>PROBLEM</operation_mode>
                    <subject>Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}</subject>
                    <message>Discovery rule: {DISCOVERY.RULE.NAME}

Device IP: {DISCOVERY.DEVICE.IPADDRESS}
Device DNS: {DISCOVERY.DEVICE.DNS}
Device status: {DISCOVERY.DEVICE.STATUS}
Device uptime: {DISCOVERY.DEVICE.UPTIME}

Device service name: {DISCOVERY.SERVICE.NAME}
Device service port: {DISCOVERY.SERVICE.PORT}
Device service status: {DISCOVERY.SERVICE.STATUS}
Device service uptime: {DISCOVERY.SERVICE.UPTIME}</message>
                </message_template>
                <message_template>
                    <event_source>AUTOREGISTRATION</event_source>
                    <operation_mode>PROBLEM</operation_mode>
                    <subject>Autoregistration: {HOST.HOST}</subject>
                    <message>Host name: {HOST.HOST}
Host IP: {HOST.IP}
Agent port: {HOST.PORT}</message>
                </message_template>
            </message_templates>
        </media_type>
    </media_types>
</zabbix_export>

